using System;
using Beamable.Microservices.Pokemon.Storage;
using Beamable.Server;
using System.Collections.Generic;
using System.Linq;
using System.Net.Http;
using System.Net.Http.Headers;
using System.Security.Cryptography;
using System.Threading.Tasks;
using Beamable.Common.Inventory;
using Beamable.Api.Autogenerated.Content;
using Beamable.Api.Autogenerated.Models;

namespace Beamable.Microservices
{
	[Microservice("GenamonService")]
	public partial class GenamonService : Microservice
	{
        [ConfigureServices]
        public static void Configure(IServiceBuilder builder)
        {
            // Services
            builder.Builder.AddSingleton(p => new HttpClient());
            builder.Builder.AddSingleton<Config>();
            builder.Builder.AddSingleton<OpenAI>();
            builder.Builder.AddSingleton<ContentUploader>();
            builder.Builder.AddSingleton<GenamonInference>();
        }
		
        [InitializeServices]
        public static async Task Init(IServiceInitializer init)
        {
            var config = init.GetService<Config>();
            await config.Init();
        }

        [Callable("status")]
        public async Task<GetStatusResponse> GetStatus()
        {
            var db = await Storage.GenamonStorageDatabase();
            var genamon = await PendingPokemonCollection.GetAvailablePokemon(db);
            
            return new GetStatusResponse {
                ready = genamon.Select(g => g.ToView()).ToList()
            };
        }

		[Callable("")]
		public async Task Generate()
		{
            var db = await Storage.GenamonStorageDatabase();
            var pendingPokemon = await PendingPokemonCollection.GetAvailablePokemon(db);
            if(pendingPokemon.Count > 0)
            {
                // Return an error here instead
                return;
            }

            var genamonInference = Provider.GetService<GenamonInference>();
            await genamonInference.Generate(2);
            await Services.Notifications.NotifyPlayer(Context.UserId, "genamon.ready", "");
        }

        [ClientCallable("collect")]
        public async Task Collect(string genamonId, ItemRef itemRef)
        {
            var db = await Storage.GenamonStorageDatabase();
            var genamonList = await PendingPokemonCollection.GetById(db, genamonId);
            
            if (genamonList.Count > 0)
            {
                var genamon = genamonList[0].ToView();
                var contentUploader = Provider.GetService<ContentUploader>();
                var imageUrl = await contentUploader.UploadFromUrl(genamon.imageUrl);
                
                await Services.Inventory.AddItem(itemRef, new Dictionary<string, string>
                {
                    {"imageUrl", imageUrl}, //workaround
                    {"name", genamon.name},
                    {"elementalType", string.Join(",", genamon.type)},
                    {"health", genamon.health.ToString()},
                    {"attack", genamon.attack.ToString()},
                    {"defense", genamon.defense.ToString()},
                    {"specialAttack", genamon.specialAttack.ToString()},
                    {"specialDefense", genamon.specialDefense.ToString()},
                    {"speed", genamon.speed.ToString()},
                    {"abilities", string.Join(',', genamon.abilities)},
                    {"moves", string.Join(',', genamon.moves)},
                    {"desc", genamon.description}
                });

                await PendingPokemonCollection.DeleteById(db, genamonId);
                await Services.Notifications.NotifyPlayer(Context.UserId, "genamon.ready", "");
            }
            else
            {
                throw new MicroserviceException(400, "GenamonUnavailable",
                    "This genamon is no longer available.");
            }
        }
	}
}
