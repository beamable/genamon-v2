using System;
using System.Text.Json;
using System.Threading.Tasks;
using Beamable.Api.Autogenerated.Accounts;
using Beamable.Common;
using Beamable.Common.Dependencies;
using Beamable.Web3SolanaFederation.Features.Accounts.Storage;
using Beamable.Web3SolanaFederation.Features.Accounts.Storage.Models;
using Microsoft.Extensions.Caching.Memory;
using Microsoft.Extensions.Options;
using Solnet.KeyStore;
using Solnet.Wallet;
using Solnet.Wallet.Bip39;
using Solnet.Wallet.Utilities;

namespace Beamable.Web3SolanaFederation.Features.Accounts;

public class AccountsService : IService
{
    private readonly IDependencyProvider _dependencyProvider;
    private readonly AccountsApi _accountsApi;
    private readonly Configuration _configuration;
    private readonly VaultCollection _vaultCollection;
    private readonly SecretKeyStoreService _secretKeyStoreService;

    private readonly MemoryCache _accountCache = new(Options.Create(new MemoryCacheOptions()));


    public AccountsService(Configuration configuration, IDependencyProvider dependencyProvider, AccountsApi accountsApi, VaultCollection vaultCollection)
    {
        _configuration = configuration;
        _dependencyProvider = dependencyProvider;
        _accountsApi = accountsApi;
        _vaultCollection = vaultCollection;
        _secretKeyStoreService = new SecretKeyStoreService();
    }

    public async Task<Account> GetOrCreateAccount(string accountName, string? existingKey = null)
    {
        var account = await GetAccount(accountName);
        if (account is null)
        {
            account = await CreateAccount(accountName);
            if (account is null)
            {
                BeamableLogger.LogWarning("Account already created, fetching again");
                return await GetOrCreateAccount(accountName);
            }

            BeamableLogger.Log("Saved account {accountName} -> {accountAddress}", accountName, account.PublicKey);
        }
        return account;
    }

    private async Task<Account?> GetAccount(string accountName)
    {
        return await _accountCache.GetOrCreateAsync(accountName, async cacheEntry =>
        {
            var vault = await _vaultCollection.GetVaultByName(accountName);
            if (vault is null)
            {
                cacheEntry.Dispose();
                return null;
            }

            cacheEntry.SlidingExpiration = TimeSpan.FromMinutes(5);
            var jsonStore = JsonSerializer.Serialize(vault.KeyStore);
            var data = _secretKeyStoreService.DecryptKeyStoreFromJson(_configuration.RealmSecret, jsonStore);
            var address = SecretKeyStoreService.GetAddressFromKeyStore(jsonStore);
            return new Account(data, Encoders.Base58.DecodeData(address));
        });
    }

    public async Task<Account?> GetAccountByAddress(string address)
    {
        var name = await GetGamerTagByWalletAddress(address);
        if (!string.IsNullOrWhiteSpace(name))
            return await GetAccount(name);
        return null;
    }

    private async Task<string?> GetGamerTagByWalletAddress(string address)
    {
        return await _vaultCollection.GetNameByAddress(address);
    }

    private async Task<Account?> CreateAccount(string accountName)
    {
        var newMnemonic = new Mnemonic(WordList.English, WordCount.Twelve);
        var wallet = new Wallet(newMnemonic);
        var newAccount = wallet.GetAccount(0);
        var jsonString = _secretKeyStoreService.EncryptAndGenerateDefaultKeyStoreAsJson(_configuration.RealmSecret, newAccount.PrivateKey, newAccount.PublicKey);

        return await _vaultCollection.TryInsertVault(new Vault
        {
            Name = accountName,
            Address = newAccount.PublicKey,
            KeyStore = JsonSerializer.Deserialize<KeyStore>(jsonString)
        })
            ? newAccount
            : null;
    }
}